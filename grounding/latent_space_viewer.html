<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Latent Space Viewer</title>
  <style>
    :root {
      --bg: #0b1014;
      --panel: rgba(13, 21, 28, 0.88);
      --text: #d9e2ea;
      --muted: #8ea1b2;
      --accent: #61e4c5;
    }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: "IBM Plex Sans", "Segoe UI", sans-serif; }
    #app { position: fixed; inset: 0; }
    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 10;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      padding: 10px 12px;
      max-width: min(420px, calc(100vw - 24px));
      backdrop-filter: blur(3px);
      line-height: 1.35;
      font-size: 13px;
    }
    #hud b { color: var(--accent); }
    #hud .muted { color: var(--muted); }
    #hud a { color: #9ad4ff; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="hud">Loading...</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.167.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.167.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const hud = document.getElementById('hud');
    const mount = document.getElementById('app');

    const params = new URLSearchParams(window.location.search);
    const dataPath = params.get('data') || '../artifacts/self_supervised_covnet_aug100_test_latent_points.json';

    function digitColor(digit) {
      const palette = [
        '#e85d75','#f08a5d','#f9c74f','#90be6d','#43aa8b',
        '#4d908e','#577590','#277da1','#9b5de5','#f15bb5'
      ];
      return new THREE.Color(palette[digit % palette.length]);
    }

    async function loadData() {
      const res = await fetch(dataPath);
      if (!res.ok) throw new Error(`Failed to fetch ${dataPath} (${res.status})`);
      return res.json();
    }

    function centerAndScale(points) {
      const n = points.length;
      let cx = 0, cy = 0, cz = 0;
      for (const p of points) { cx += p[0]; cy += p[1]; cz += p[2]; }
      cx /= n; cy /= n; cz /= n;

      let maxR = 1;
      for (const p of points) {
        p[0] -= cx; p[1] -= cy; p[2] -= cz;
        const r = Math.hypot(p[0], p[1], p[2]);
        if (r > maxR) maxR = r;
      }
      const s = 12 / maxR;
      for (const p of points) { p[0] *= s; p[1] *= s; p[2] *= s; }
    }

    function buildScene(data) {
      const scene = new THREE.Scene();
      scene.background = new THREE.Color('#0b1014');
      scene.add(new THREE.AxesHelper(8));

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
      camera.position.set(0, 0, 28);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      mount.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const points = data.points.map((p) => [p[0], p[1], p[2]]);
      centerAndScale(points);

      const n = points.length;
      const positions = new Float32Array(n * 3);
      const colors = new Float32Array(n * 3);

      for (let i = 0; i < n; i++) {
        const p = points[i];
        const c = digitColor(data.labels[i]);
        positions[i * 3 + 0] = p[0];
        positions[i * 3 + 1] = p[1];
        positions[i * 3 + 2] = p[2];
        colors[i * 3 + 0] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({ size: 0.11, vertexColors: true, opacity: 0.9, transparent: true });
      const cloud = new THREE.Points(geometry, material);
      scene.add(cloud);

      const ambient = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambient);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      function animate() {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
    }

    function renderHud(data) {
      const umapCfg = data.projection === 'umap_3d'
        ? `UMAP(n_neighbors=${data.umap_n_neighbors}, min_dist=${data.umap_min_dist})`
        : '';
      hud.innerHTML = `
        <div><b>${data.experiment}</b> (${data.split})</div>
        <div class="muted">points: ${data.num_points} | latent_dim: ${data.latent_dim} | L2: ${data.l2_normalized}</div>
        <div class="muted">projection: ${data.projection}</div>
        <div class="muted">${umapCfg}</div>
        <div class="muted">data: ${dataPath}</div>
        <div class="muted">Tip: drag to orbit, scroll to zoom.</div>
      `;
    }

    loadData()
      .then((data) => {
        renderHud(data);
        buildScene(data);
      })
      .catch((err) => {
        hud.innerHTML = `<b>Failed to load data</b><br><span class="muted">${err.message}</span><br><span class="muted">Open this file through a local server and pass ?data=... path to JSON.</span>`;
        console.error(err);
      });
  </script>
</body>
</html>
